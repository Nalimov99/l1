# Устные вопросы

### 1. Какой самый эффективный способ конкатенации строк?
Самым эфективным способом конкатенации строк является strings.Builder, т.к. он минимизирует количество копирований памяти для конкатенации строк.
```go
func main() {
    var sb strings.Builder
    for i := 0; i < 1000; i++ {
        sb.WriteString("a")
    }
    fmt.Println(sb.String())
}
```

### 2. Что такое интерфейсы, как они применяются в Go?
Интерфейс предствляет из себя контракт, который определяет набор методов. Чтобы тип удволетворял интерфейсу, необходимо реализовать все методы описанные в интерфейсе. <br />
Если имеються разные типы данных, но реализующих один интерфейс, мы можем сгрупировать их по типу интерфейса, для дальнейшего вызова методов этой группы.

### 3. Чем отличаются RWMutex от Mutex?
RWMutex представляет из себя расширенный Mutex. При вызове .RLock(), только вызовы .Lock() в других горутинах блокируются, а вызовы .RLock() спокойно проходят. <br />
То есть RWMutex позволяет безопасно предосталвять доступ на параллельное чтение. <br />
RWMutex предпочтительнее использовать тогда, когда количество чтений намного больше чем записей. Из-за того что RWMutex обеспечивает параллельное чтение, его скорость ниже чем у Mutex.

### 4. Чем отличаются буферизированные и не буферизированные каналы?
При отправке данных в буферизированный канал горутина-отправитель ожидает, пока в канале не освободится место для еще одного элемента и отправляет элемент, только тогда, когда в канале освобождается для него место.

### 5. Какой размер у структуры struct{}{}?
0 байт.

### 6. Есть ли в Go перегрузка методов или операторов?
Перегрузки операторов нет. (можно использовать дженерики, но это не совсем то) <br />
Для перегрузки методов можно использовать композицию, но метод первоначальной структуры изменить нельзя.

### 7. В какой последовательности будут выведены элементы map[int]int?
Пример:
```go
m[0]=1
m[1]=124
m[2]=281
```
В случайно последовательности.

### 8. В чем разница make и new?
Make создает только slice, map, chan и возвращает их инициализированное значение. <br />
С помощью new инициализруется элемент с нулевым значением и возвращается указатель.

### 9. Сколько существует способов задать переменную типа slice или map?
Если с инициализацией то 3
```go
// map
var m map[string]string
m := make(map[string]string)
m := map[string]string{}

// slice
var s []string
s := make([]string)
s := []string{}
```

### 10. Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  // чтобы заменить значение внешней p необходимо разыменовывать указатель:
  // *p = 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

```
```
Output:
1
1
```
При передаче указателя в качестве аргумента, компируется значение указателя p. Чтобы заменить значение у внешней p, необходимо разыменовывать указатель: *p = b

### 11. Что выведет данная программа и почему?
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
```
Output: Deadlock
```
Wg должна передаваться только по указателю. В данном примере можно вообще не передавать wg.

### 12. Что выведет данная программа и почему?
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
```
Output: 0
```
n инициализируется в новой области видимости.

### 13. Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
```
Output: [100 2 3 4 5]
```
Слайс внутри себя содержит указатель на массив. Когда меняется элемент по индексу, он меняется в массиве на который указывает слайс. <br />
Функция append возвращает новый слайс, поэтому на внешний слайс это никак не влияет

### 14. Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
```
Output: [b b a][a a]
```
При передачи slice в функцию его capacity равна сapacity переданного слайса. <br />
В данном случае capacity будет равна 2. Поэтому когда происходит append, аллоцируется новый массив и внутренний слайс указывает на него.
